<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Promise | books</title>
    <meta name="description" content="个人收藏夹">
    <link rel="icon" href="/books/favicon.ico">
    
    <link rel="preload" href="/books/assets/css/0.styles.3bf99c69.css" as="style"><link rel="preload" href="/books/assets/js/app.b36598ad.js" as="script"><link rel="preload" href="/books/assets/js/76.fe474c6d.js" as="script"><link rel="prefetch" href="/books/assets/js/10.7897c5b8.js"><link rel="prefetch" href="/books/assets/js/11.e894313e.js"><link rel="prefetch" href="/books/assets/js/12.962e2c4f.js"><link rel="prefetch" href="/books/assets/js/13.9201c7e6.js"><link rel="prefetch" href="/books/assets/js/14.0b55444d.js"><link rel="prefetch" href="/books/assets/js/15.3b3bb3a2.js"><link rel="prefetch" href="/books/assets/js/16.8f2c4bea.js"><link rel="prefetch" href="/books/assets/js/17.7654d120.js"><link rel="prefetch" href="/books/assets/js/18.1f7ab18a.js"><link rel="prefetch" href="/books/assets/js/19.c2fca292.js"><link rel="prefetch" href="/books/assets/js/2.854dcf62.js"><link rel="prefetch" href="/books/assets/js/20.aea1b77d.js"><link rel="prefetch" href="/books/assets/js/21.c526f4c7.js"><link rel="prefetch" href="/books/assets/js/22.0bf0a208.js"><link rel="prefetch" href="/books/assets/js/23.59f9e2aa.js"><link rel="prefetch" href="/books/assets/js/24.725d88fc.js"><link rel="prefetch" href="/books/assets/js/25.10d52890.js"><link rel="prefetch" href="/books/assets/js/26.009f0277.js"><link rel="prefetch" href="/books/assets/js/27.02ad3b73.js"><link rel="prefetch" href="/books/assets/js/28.203a6daf.js"><link rel="prefetch" href="/books/assets/js/29.46c08610.js"><link rel="prefetch" href="/books/assets/js/3.8b2a45ed.js"><link rel="prefetch" href="/books/assets/js/30.820acf4b.js"><link rel="prefetch" href="/books/assets/js/31.50888028.js"><link rel="prefetch" href="/books/assets/js/32.595bc6da.js"><link rel="prefetch" href="/books/assets/js/33.faae8c92.js"><link rel="prefetch" href="/books/assets/js/34.bb3ad3b5.js"><link rel="prefetch" href="/books/assets/js/35.aea321d7.js"><link rel="prefetch" href="/books/assets/js/36.db3c532a.js"><link rel="prefetch" href="/books/assets/js/37.2becdc05.js"><link rel="prefetch" href="/books/assets/js/38.96b2e4f2.js"><link rel="prefetch" href="/books/assets/js/39.b167b6ef.js"><link rel="prefetch" href="/books/assets/js/4.c4f29f89.js"><link rel="prefetch" href="/books/assets/js/40.2ca9b918.js"><link rel="prefetch" href="/books/assets/js/41.fbfdaee3.js"><link rel="prefetch" href="/books/assets/js/42.a4739ab1.js"><link rel="prefetch" href="/books/assets/js/43.28ad91e9.js"><link rel="prefetch" href="/books/assets/js/44.a9a3edaa.js"><link rel="prefetch" href="/books/assets/js/45.abbb313c.js"><link rel="prefetch" href="/books/assets/js/46.4eb51b82.js"><link rel="prefetch" href="/books/assets/js/47.56bfa831.js"><link rel="prefetch" href="/books/assets/js/48.3b667ef9.js"><link rel="prefetch" href="/books/assets/js/49.ca302f86.js"><link rel="prefetch" href="/books/assets/js/5.7590f93c.js"><link rel="prefetch" href="/books/assets/js/50.1928e985.js"><link rel="prefetch" href="/books/assets/js/51.7e28878b.js"><link rel="prefetch" href="/books/assets/js/52.d89f2d14.js"><link rel="prefetch" href="/books/assets/js/53.b4ff237f.js"><link rel="prefetch" href="/books/assets/js/54.3652c567.js"><link rel="prefetch" href="/books/assets/js/55.d9ea3aea.js"><link rel="prefetch" href="/books/assets/js/56.0110954b.js"><link rel="prefetch" href="/books/assets/js/57.3a69bcfc.js"><link rel="prefetch" href="/books/assets/js/58.ab353971.js"><link rel="prefetch" href="/books/assets/js/59.953ccfa9.js"><link rel="prefetch" href="/books/assets/js/6.6174f641.js"><link rel="prefetch" href="/books/assets/js/60.efd03434.js"><link rel="prefetch" href="/books/assets/js/61.bd9f009e.js"><link rel="prefetch" href="/books/assets/js/62.15e1ab44.js"><link rel="prefetch" href="/books/assets/js/63.16d3a4df.js"><link rel="prefetch" href="/books/assets/js/64.a0954bd4.js"><link rel="prefetch" href="/books/assets/js/65.7f913bc2.js"><link rel="prefetch" href="/books/assets/js/66.dcc05852.js"><link rel="prefetch" href="/books/assets/js/67.1470a51f.js"><link rel="prefetch" href="/books/assets/js/68.11002c8e.js"><link rel="prefetch" href="/books/assets/js/69.390f12c1.js"><link rel="prefetch" href="/books/assets/js/7.6ca50e07.js"><link rel="prefetch" href="/books/assets/js/70.03aa08fb.js"><link rel="prefetch" href="/books/assets/js/71.6ea02cb9.js"><link rel="prefetch" href="/books/assets/js/72.351fb33a.js"><link rel="prefetch" href="/books/assets/js/73.8c65e50d.js"><link rel="prefetch" href="/books/assets/js/74.18429298.js"><link rel="prefetch" href="/books/assets/js/75.7b992bc1.js"><link rel="prefetch" href="/books/assets/js/77.8e28d671.js"><link rel="prefetch" href="/books/assets/js/78.4ace73ca.js"><link rel="prefetch" href="/books/assets/js/79.8422084d.js"><link rel="prefetch" href="/books/assets/js/8.957cb170.js"><link rel="prefetch" href="/books/assets/js/80.d0153dac.js"><link rel="prefetch" href="/books/assets/js/81.8b346674.js"><link rel="prefetch" href="/books/assets/js/82.ddfadeea.js"><link rel="prefetch" href="/books/assets/js/9.9308df7e.js">
    <link rel="stylesheet" href="/books/assets/css/0.styles.3bf99c69.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/books/" class="home-link router-link-active"><!----> <span class="site-name">books</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/books/" class="nav-link">首页</a></div><div class="nav-item"><a href="/books/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/books/gitcommit/" class="nav-link">gitcommit</a></div><div class="nav-item"><a href="/books/uniapp/" class="nav-link">uniapp开发实践</a></div><div class="nav-item"><a href="/books/typeScript/" class="nav-link">TypeScript</a></div><div class="nav-item"><a href="/books/misc/" class="nav-link router-link-active">杂项</a></div><div class="nav-item"><a href="/books/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/books/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/books/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/books/blog/" class="nav-link">Blog</a></div> <a href="https://github.com/yuguaa/books" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/books/" class="nav-link">首页</a></div><div class="nav-item"><a href="/books/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/books/gitcommit/" class="nav-link">gitcommit</a></div><div class="nav-item"><a href="/books/uniapp/" class="nav-link">uniapp开发实践</a></div><div class="nav-item"><a href="/books/typeScript/" class="nav-link">TypeScript</a></div><div class="nav-item"><a href="/books/misc/" class="nav-link router-link-active">杂项</a></div><div class="nav-item"><a href="/books/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/books/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/books/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/books/blog/" class="nav-link">Blog</a></div> <a href="https://github.com/yuguaa/books" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>杂项</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/books/misc/js常见算法.html" class="sidebar-link">冒泡排序</a></li><li><a href="/books/misc/react.html" class="sidebar-link">React 面试题</a></li><li><a href="/books/misc/" aria-current="page" class="sidebar-link">杂项</a></li><li><a href="/books/misc/vue-react.html" class="sidebar-link">v-once</a></li><li><a href="/books/misc/vue指令.html" class="sidebar-link">v-once</a></li><li><a href="/books/misc/参考链接.html" class="sidebar-link">1.js</a></li><li><a href="/books/misc/常见题面试题总结.html" class="sidebar-link">谈谈变量提升</a></li><li><a href="/books/misc/性能优化.html" class="sidebar-link">一．源码优化</a></li><li><a href="/books/misc/路由拦截，http拦截.html" class="sidebar-link">路由拦截</a></li><li><a href="/books/misc/面试.html" class="sidebar-link">1. 为什么使用 promise，怎么使用</a></li><li><a href="/books/misc/面试进阶.html" class="active sidebar-link">Promise</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/books/misc/项目相关.html" class="sidebar-link">1.需求评审</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h3 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h3> <h5 id="promise-all-批量执行"><a href="#promise-all-批量执行" class="header-anchor">#</a> Promise.all() 批量执行</h5> <p>Promise.all([p1, p2, p3])用于将多个 promise 实例，包装成一个新的 Promise 实例，返回的实例就是普通的 promise
它接收一个数组作为参数
数组里可以是 Promise 对象，也可以是别的值，只有 Promise 会等待状态改变
当所有的子 Promise 都完成，该 Promise 完成，返回值是全部值得数组
有任何一个失败，该 Promise 失败，返回值是第一个失败的子 Promise 结果</p> <h5 id="promise-race-类似于-promise-all-，区别在于它有任意一个完成就算完成"><a href="#promise-race-类似于-promise-all-，区别在于它有任意一个完成就算完成" class="header-anchor">#</a> Promise.race() 类似于 Promise.all() ，区别在于它有任意一个完成就算完成</h5> <p>常见用法：
异步操作和定时器放在一起，，如果定时器先触发，就认为超时，告知用户；
例如我们要从远程的服务家在资源如果 5000ms 还没有加载过来我们就告知用户加载失败</p> <p>现实中的用法
回调包装成 Promise，他有两个显而易见的好处：
1、可读性好
2、返回 的结果可以加入任何 Promise 队列</p> <p>作者：王云飞_小四_wyunfei
链接：https://www.jianshu.com/p/1b63a13c2701
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <h3 id="懒加载"><a href="#懒加载" class="header-anchor">#</a> 懒加载</h3> <p>作为网页内容的一部分，图像和视频通常要消耗很多资源加载。要提高网页应用的性能，如何避免资源浪费在加载图像和视频上就很重要了。但是，很多时候我们都不愿意减少网页上的媒体资源，所以我们经常无从下手。幸运的是，我们有懒加载这个绝招，它可以帮助我们减少加载时间和降低负载，而不在内容上偷工减料。</p> <p><strong>什么是懒加载？</strong></p> <p>懒加载是一种在页面加载时延迟加载一些非关键资源的技术，换句话说就是按需加载。对于图片来说，非关键通常意味着离屏。如果你有使用过 Lighthouse 并且做过一些性能调优，你可能已经见过一些离屏图片的应用。<a href="https://link.jianshu.com?t=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Flighthouse%2Faudits%2Foffscreen-images" target="_blank" rel="noopener noreferrer">(offscreen-images)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https:////upload-images.jianshu.io/upload_images/5070211-a85350f6ac063ddc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/759/format/webp" alt="img"></p> <p>我们之前看到的懒加载一般是这样的形式：</p> <ol><li>浏览一个网页，准备往下拖动滚动条</li> <li>拖动一个占位图片到视窗</li> <li>占位图片被瞬间替换成最终的图片</li></ol> <p>我们可以在<a href="https://link.jianshu.com?t=https%3A%2F%2Fmedium.com" target="_blank" rel="noopener noreferrer">Medium<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中看到懒加载是如何使用的，网页首先用一张轻量级的图片占位，当占位图片被拖动到视窗，瞬间加载目标图片，然后替换占位图片。</p> <p><img src="https:////upload-images.jianshu.io/upload_images/5070211-b4120bdbd5933573.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/812/format/webp" alt="img"></p> <p>如果你不是很熟悉懒加载技术，你或许会疑问它有什么用，能为我们带来什么好处，下面我们将会探讨这个问题。</p> <p><strong>为什么要懒加载而不直接加载？</strong></p> <ul><li>浪费流量。在不计流量收费的网络，这可能不重要；在按流量收费的网络中，毫无疑问，一次性加载大量图片就是在浪费用户的钱。</li> <li>消耗额外的电量和其他的系统资源，并且延长了浏览器解析的时间。因为媒体资源在被下载完成后，浏览器必须对它进行解码，然后渲染在视窗上，这些操作都需要一定的时间。</li></ul> <p>懒加载图片和视频，可以减少页面加载的时间、页面的大小和降低系统资源的占用，这些对于性能都有显著地提升。在这里，我们将会提到一些懒加载技术和使用方法，还有一些常用的<a href="https://link.jianshu.com?t=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Flazy-loading-guidance%2Fimages-and-video%2F%23lazy_loading_libraries" target="_blank" rel="noopener noreferrer">懒加载库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p><strong>懒加载图片</strong></p> <p>图片懒加载在技术上实现很简单，不过对于细节要求比较严格。目前有很多实现懒加载的方法，先从懒加载内联图片说起吧。</p> <h6 id="内联图片"><a href="#内联图片" class="header-anchor">#</a> 内联图片</h6> <p>最常见的懒加载方式就是利用<code>&lt;img&gt;</code>标签。懒加载图片时，我们利用 JavaScript 检查<code>&lt;img&gt;</code>标签是否在视窗中。如果在，<code>&lt;img&gt;</code>的 src（有时候是 srcset）就会设置为目标图片的 url。</p> <h6 id="利用-intersection-observer"><a href="#利用-intersection-observer" class="header-anchor">#</a> 利用 intersection observer</h6> <p>如果你之前用过懒加载，你很可能是通过监听一些事件比如<code>scroll</code>或者<code>resize</code>来检测元素出现在视窗，这种方法很成熟，能够兼容大部分的浏览器。但是，现代浏览器提供了一个更好的方法给我们(<a href="https://link.jianshu.com?t=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2016%2F04%2Fintersectionobserver" target="_blank" rel="noopener noreferrer">the intersection observer API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)</p> <blockquote><p><em>注意：Intersection observer 目前只能在 Chrome63+和 firefox58+使用</em></p></blockquote> <p>作者：Naeco
链接：https://www.jianshu.com/p/e86c61468285
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <h3 id="js-基本数据类型"><a href="#js-基本数据类型" class="header-anchor">#</a> JS 基本数据类型</h3> <p>String，Number，Boolean，Null，undefined</p> <p>console.log(typeof(null));//object</p> <p>console.log(typeof(NaN));//number</p> <p>console.log(typeof(undefined));//undefined</p> <h3 id="computed-和-watch"><a href="#computed-和-watch" class="header-anchor">#</a> computed 和 watch</h3> <p>当需要在数据变化时执行异步或开销较大的操作时，watch 这个方式是最有用的。</p> <p>对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p> <h3 id="vue-路由传参"><a href="#vue-路由传参" class="header-anchor">#</a> vue 路由传参</h3> <p>1.命名路由搭配 params，刷新页面参数会丢失 2.查询参数搭配 query，刷新页面数据不会丢失 3.接受参数使用 this.$router 后面就是搭配路由的名称就能获取到参数的值</p> <h3 id="vue-刷新当前页面的方法"><a href="#vue-刷新当前页面的方法" class="header-anchor">#</a> vue 刷新当前页面的方法</h3> <p>遇到一个页面刷新的问题，记录一下</p> <p>1、this.$router.go(0)</p> <p>这种方法页面会一瞬间的白屏，体验不是很好，虽然只是一行代码的事</p> <p>2、location.reload()</p> <p>这种也是一样，画面一闪，效果总不是很好</p> <p>3、跳转空白页再跳回原页面</p> <p>在需要页面刷新的地方写上：this.$router.push('/emptyPage')，跳转到一个空白页。在 emptyPage.vue 里 beforeRouteEnter 钩子里控制页面跳转，从而达到刷新的效果</p> <p>beforeRouteEnter (to, from, next) {
next(vm =&gt; {
vm.$router.replace(from.path)
})
}。</p> <p>这种画面虽不会一闪，但是能看见路由快速变化。</p> <p>4、控制<!----></p> <p>默认<!---->isRouterAlive 肯定是 true，在需要刷新的时候把这个值设为 false，接着再重新设为 true：</p> <h3 id="hash-模式和-history-模式的不同"><a href="#hash-模式和-history-模式的不同" class="header-anchor">#</a> hash 模式和 history 模式的不同</h3> <p>对于 vue 这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。</p> <p><strong>为了达到这一目的，浏览器当前提供了以下两种支持：</strong></p> <ul><li>hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li> <li>history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。</li> <li>因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由.</li></ul> <p><strong>使用场景</strong></p> <p>一般场景下，hash 和 history 都可以，除非你更在意颜值，# 符号夹杂在 URL 里看起来确实有些不太美丽。</p> <p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p> <p>另外，根据 Mozilla Develop Network 的介绍，调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p> <ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li> <li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li> <li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li> <li>pushState() 可额外设置 title 属性供后续使用。</li></ul> <p>当然啦，history 也不是样样都好。SPA 虽然在浏览器里游刃有余，但真要通过 URL 向后端发起 HTTP 请求时，两者的差异就来了。尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。</p> <p>个人在接入微信的一个活动开发过程中 开始使用的 hash 模式，但是后面后端无法获取到我#后面的 url 参数，于是就把参数写在#前面，但是讨论后还是决定去掉这个巨丑的#</p> <p>于是乎改用 history 模式，但是开始跑流程的时候是没问题，但是后来发现跳转后刷新或者回跳，会报一个 404 的错误，找不到指定的路由,最后后端去指向正确的路由 加了/hd/xxx 去匹配是否有这个/hd/{:path} 才得以解决</p> <p><strong>总结</strong></p> <p>1 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.abc.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</p> <p>2 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.abc.com/book/id。如果后端缺少对 /book/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p> <p>3 结合自身例子，对于一般的 Vue + Vue-Router + Webpack + XXX 形式的 Web 开发场景，用 history 模式即可，只需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。</p> <p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。</p> <h3 id="axios-和-ajax"><a href="#axios-和-ajax" class="header-anchor">#</a> axios 和 ajax</h3> <ul><li><p>传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始 js 中，核心使用 XMLHttpRequest 对象，多个请求之间如果有先后关系的话，就会出现<strong>回调地狱</strong>。</p></li> <li><p>JQuery ajax 是对原生 XHR 的封装，除此以外还增添了对<strong>JSONP</strong>的支持。经过多年的更新维护，真的已经是非常的方便了，优点无需多言；如果是硬要举出几个缺点，那可能只有： 1.本身是针对 MVC 的编程,不符合现在前端<strong>MVVM</strong>的浪潮 2.基于原生的 XHR 开发，XHR 本身的架构不清晰。
3.JQuery 整个项目太大，单纯使用 ajax 却要引入整个 JQuery 非常的不合理（采取个性化打包的方案又不能享受 C DN 服务） 4.不符合关注分离（Separation of Concerns）的原则 5.配置和调用方式非常混乱，而且基于事件的异步模型不友好。</p></li> <li><p>axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征： 1.从浏览器中创建 XMLHttpRequest 2.支持 Promise API 3.客户端支持防止 CSRF 4.提供了一些并发请求的接口（重要，方便了很多的操作） 5.从 node.js 创建 http 请求 6.拦截请求和响应 7.转换请求和响应数据 8.取消请求 9.自动转换 JSON 数据
<strong>PS:防止 CSRF:就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</strong></p></li> <li><p><strong>3.fetch</strong></p></li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Oops, error'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的。Fetch 的代码结构比起 ajax 简单多了，参数有点像 jQuery ajax。但是，一定记住<strong>fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象</strong>。
fetch 的优点： 1.符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里 2.更好更方便的写法
坦白说，上面的理由对我来说完全没有什么说服力，因为不管是 Jquery 还是 Axios 都已经帮我们把 xhr 封装的足够好，使用起来也足够方便，为什么我们还要花费大力气去学习 fetch？
我认为 fetch 的优势主要优势就是：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token number">1.</span>  语法简洁，更加语义化
<span class="token number">2.</span>  基于标准 Promise 实现，支持 async<span class="token operator">/</span><span class="token keyword">await</span>
<span class="token number">3.</span>  同构方便，使用 <span class="token punctuation">[</span>isomorphic<span class="token operator">-</span>fetch<span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>matthew<span class="token operator">-</span>andrews<span class="token operator">/</span>isomorphic<span class="token operator">-</span>fetch<span class="token punctuation">)</span>
<span class="token number">4.</span>更加底层，提供的<span class="token constant">API</span>丰富（request<span class="token punctuation">,</span> response）
<span class="token number">5.</span>脱离了<span class="token constant">XHR</span>，是<span class="token constant">ES</span>规范里新的实现方式
</code></pre></div><p>最近在使用 fetch 的时候，也遇到了不少的问题：
fetch 是一个低层次的 API，你可以把它考虑成原生的 XHR，所以使用起来并不是那么舒服，需要进行封装。
例如：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">1）fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
2）fetch默认不会带cookie，需要添加配置项： fetch(url,</span> <span class="token punctuation">{</span><span class="token property">credentials</span><span class="token punctuation">:</span> <span class="token string">'include'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
4）fetch没有办法原生监测请求的进度，而XHR可以
</code></pre></div><p><strong>总结：axios 既提供了并发的封装，也没有 fetch 的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。</strong></p> <p>作者：赵客缦胡缨 v 吴钩霜雪明
链接：https://www.jianshu.com/p/8bc48f8fde75
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p><strong>当一个函数返回它内部定义的一个函数时，就产生了一个闭包，闭包不但包括被返回的函数，还包括这个函数的定义环境。</strong></p> <p>https://www.haorooms.com/post/js_bb</p> <p>当一个函数 A 的作用域被内部的 B 函数引用时，A 函数的作用域就会被 B 函数闭包，如果函数 A 返回了函数 B，当 A 函数执行完毕时，A 函数的作用域也不会释放。</p> <p>优点：</p> <p>闭包可以实现对象的私有属性和私有方法。</p> <p>闭包可以封装变量，从简减少对全局作用域的污染。</p> <p>缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致<strong>内存泄露</strong>。<strong>解决方法是，在退出函数之前，将不使用的局部变量全部删除。</strong></p> <h3 id="什么是原型和原型链？"><a href="#什么是原型和原型链？" class="header-anchor">#</a> 什么是原型和原型链？</h3> <p>https://blog.csdn.net/xiaoermingn/article/details/80745117</p> <p>Js 中的对象都有一个属性叫做<strong>proto</strong>(也是一个对象)，表示对象的原型。当访问对象中的属性或方法时，首先在对象本身中寻找，如果找不到则会在原型中寻找，原型中也找不到时会在原型的原型中寻找，直到最顶层为止。</p> <p>js 中的类(构造函数)都有一个 prototype 的属性，表示本类的原型类型，通过这个类实例化的对象(这个构造函数创建的对象)， <strong>proto</strong>都指向本类的 prototype，从而实现了类方法的共享。一个类的 prototype 也是一个对象，它也有<strong>proto</strong>，把它的<strong>proto</strong>指向另一个类的 prototype 时，那么这个类的对象就能访问另一个类中的方法，从而实现了方法的继承。</p> <p>A 类的 prototype.<strong>proto</strong>指向另一个类 B，B 的 prototype.<strong>proto</strong>又可以指向 C，这种结构叫做原型链。</p> <h3 id="new-对象"><a href="#new-对象" class="header-anchor">#</a> new 对象</h3> <ul><li>创建一个空对象</li> <li>将所创建对象的<strong>proto</strong>属性值设为构造函数的 prototype 的属性值</li> <li>执行构造函数中的代码，构造函数中的 this 指向该对象</li> <li>返回对象</li></ul> <h3 id="redux-工作流程"><a href="#redux-工作流程" class="header-anchor">#</a> Redux 工作流程</h3> <blockquote><p>之前在公司学习 react 的时候没有学习 redux 而是以开始就让我学习使用 Dva ,Dva 是阿里系的框架,最近也是很火,受到许多使用 react 公司的青睐,毕竟学习成本比 redux 要低很多;然而想要成为 react 方向的前端程序员,redux 肯定是使用的更多的,Redux 是目前 React 生态中，最好的数据层框架,所以在前一段时间就开始学习 redux 并最终完成一些项目,</p></blockquote> <blockquote><p>作为程序员,分享是最基本的素养,我接下来将会把每天的学习成果在此分享,希望能有一起学习的同学交流分享</p></blockquote> <blockquote><p>(本文章是参考 jsp.com 播客编写,有兴趣的可以去阅读,目前是我遇到最喜欢的 react 教程)</p></blockquote> <blockquote><p>Redux 是目前 React 生态中最好的数据层框架,理解 redux 最重要的就是他的数据流向,官方文档中清楚的给出了数据流向图!!!!</p> <p><img src="https:////upload-images.jianshu.io/upload_images/19876323-695042e776ea058f?imageMogr2/auto-orient/strip%7CimageView2/2/w/828/format/webp" alt="img"></p> <p>Redux 数据流向图</p></blockquote> <blockquote><p>如上图中 更能清楚明白 redux 对于 javascript 应用而言是一个可预测状态的容器，即它是一个数据流框架。</p></blockquote> <blockquote><p>redux 主要用作应用状态的管理，即 redux 用一个单独的常量状态树（对象）保持这一整个应用的状态，这个对象不能直接被改变。如果一些数据变化了，一个新的对象就会被创建（使用 action 和 reducers）</p></blockquote> <p>刚学习 react 的同学最头疼的是数据流向了,那么怎么更清楚的理解 redux 官方文档给出的数据流向图呢????? 我们先完整介绍流程</p> <blockquote><p>图中容易看出所有的东西都是以 store 为核心,我们把它看成数据存储中心,数据银行,但是他要更改数据的时候不能直接修改,数据修改更新的角色由 Reducers 来担任, store 只做存储,中间人,当 Reducers 的更新完成以后会通过 store 的订阅来通知 react component ,组件把新的状态重新获取渲染,组件中我们也能主动发送 action,创建 action 后这个动作是不会执行的,所以要 dispatch 这个 action,让 store 通过 reducers 去做更新</p></blockquote> <blockquote><p>React Component 就是 react 的每个组件啦</p></blockquote> <p>额~~~,是不是有些小伙伴还是不太懂,那我们举个栗子吧</p> <blockquote><p>React Component---人想去贷款创业</p></blockquote> <blockquote><p>store ----银行的钱</p></blockquote> <blockquote><p>Reducers----银行信贷系统</p></blockquote> <blockquote><p>Action Creator----人自己去贷款的动作</p></blockquote> <blockquote><p>你细品下.......</p></blockquote> <blockquote><p>你(React Component)想改变自己的经济状况,产生一个去贷款的动作(Action Creato),找到了银行的钱(store),管理员调用信贷系统(Reducers),管理员把钱给你,你变了你的经济状况(更改了状态重新渲染组件)</p></blockquote> <p>作者：前端拓路者
链接：https://www.jianshu.com/p/a5859193b646
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <h3 id="纯函数-pure-function"><a href="#纯函数-pure-function" class="header-anchor">#</a> 纯函数 Pure Function</h3> <p>**定义：**一个函数的返回结果只依赖于它的参数，并且在执行的过程中没有副作用，我们就把该函数称作纯函数。</p> <p><strong>什么是副作用</strong>
除了修改外部的变量，一个函数在执行过程中还有很多方式产生外部可观察的变化，比如说调用 DOM API 修改页面，或者你发送了 Ajax 请求，还有调用 window.reload 刷新浏览器，甚至是 console.log 往控制台打印数据也是副作用。</p> <p><strong>3.没有额外的状态依赖</strong>
指方法内的状态都只在方法的生命周期内存活，这意味着不能在方法内使用共享变量，因为会带来不可知因素。</p> <p><strong>为什么需要纯函数？</strong>
因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。</p> <p>作者：小进进不将就
链接：https://www.jianshu.com/p/abe45e83fda7
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <h3 id="vue-生命周期钩子函数"><a href="#vue-生命周期钩子函数" class="header-anchor">#</a> vue 生命周期钩子函数</h3> <p><code>beforeCreate</code>
**官方说明：**在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。
**解释：**这个时期，this 变量还不能使用，在 data 下的数据，和 methods 下的方法，watcher 中的事件都不能获得到；</p> <p><code>created</code>
**官方说明：**实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
<strong>解释说明：</strong> 这个时候可以操作 vue 实例中的数据和各种方法，但是还不能对&quot;dom&quot;节点进行操作；</p> <p><code>beforeMounte</code>
**官方说明：**在挂载开始之前被调用：相关的 render 函数首次被调用。</p> <p><code>mounted</code> <strong>官方说明：</strong><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果<code>root</code>实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。
**解释说明：**挂载完毕，这时<code>dom</code>节点被渲染到文档内，一些需要<code>dom</code>的操作在此时才能正常进行</p> <hr> <ol><li>beforeUpdate：$vm.data更新之后，<strong>虚拟DOM重新渲染</strong> 和打补丁之前被调用。
你可以在这个钩子中进一步地修改$vm.data，这不会触发附加的重渲染过程。</li> <li>updated：<strong>虚拟 DOM 重新渲染</strong> 和打补丁之后被调用。
当这个钩子被调用时，组件 DOM 的 data 已经更新，所以你现在可以执行依赖于 DOM 的操作。但是不要在此时修改 data，否则会继续触发 beforeUpdate、updated 这两个生命周期，进入死循环！</li> <li>beforeDestroy：实例被销毁之前调用。在这一步，实例仍然完全可用。
实例要被销毁了，赶在被销毁之前搞点事情吧哈哈~</li> <li>destroyed：Vue 实例销毁后调用。此时，Vue 实例指示的所有东西已经解绑定，所有的事件监听器都已经被移除，所有的子实例也已经被销毁。
这时候能做的事情已经不多了，只能加点儿提示 toast 之类的东西吧。</li></ol> <p><strong>注</strong>：beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed 这几个钩子函数，在服务器端渲染期间不被调用。</p> <hr> <p>作者：任无名 F
链接：https://www.jianshu.com/p/a20f2023c78a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <h3 id="react-中调用-setstate-之后发生了什么事情"><a href="#react-中调用-setstate-之后发生了什么事情" class="header-anchor">#</a> React 中调用 setState 之后发生了什么事情?</h3> <p>React 会将当前传入的参数对象与组件当前的状态合并,然后触发调和过程,在调和的过程中,React 会以相对高效的方式根据新的状态构建 React 元素树并且重新渲染整个 UI 界面.</p> <p>React 得到的元素树之后,React 会自动计算出新的树与老的树的节点的差异,然后根据差异对界面进行最小化的渲染,在 React 的差异算法中,React 能够精确的知道在哪些位置发生看改变以及应该如何去改变,这样就保证了 UI 是按需更新的而不是重新渲染整个界面.</p> <p>作者：vbuer
链接：https://www.jianshu.com/p/2f2d73e1ad5b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> <h3 id="vue-router-路由钩子函数-导航守卫"><a href="#vue-router-路由钩子函数-导航守卫" class="header-anchor">#</a> Vue-Router 路由钩子函数(导航守卫)</h3> <p><a href="https://www.jianshu.com/u/0f5f06120371" target="_blank" rel="noopener noreferrer"><img src="https://upload.jianshu.io/users/upload_avatars/14942208/40bfec8e-98a3-4ebc-9003-d7aabbb6076b.jpg?imageMogr2/auto-orient/strip%7CimageView2/1/w/96/h/96/format/webp" alt="img"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/u/0f5f06120371" target="_blank" rel="noopener noreferrer">G_弦上的咏叹调<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>关注</p> <p>0.9272019.01.20 22:57:07 字数 975 阅读 5,845</p> <p>—— <strong>“导航”表示路由正在发生改变。</strong></p> <p>路由钩子函数有三种：</p> <p>​ 1：全局钩子： beforeEach、 afterEach</p> <p>​ 2：单个路由里面的钩子： beforeEnter、 beforeLeave</p> <p>​ 3:组件路由：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave</p> <h5 id="_1-全局守卫"><a href="#_1-全局守卫" class="header-anchor">#</a> <strong>1.全局守卫</strong></h5> <p><strong>无论访问哪一个路径，都会触发全局的钩子函数，位置是调用 router 的方法</strong></p> <p><strong>router.beforeEach() 进入之前触发</strong></p> <p><strong>router.afterEach() 进入之后触发</strong></p> <p>**
**</p> <p><strong>⑴ beforeEach（全局前置守卫）</strong></p> <p>使用 router.beforeEach 注册一个全局前置守卫</p> <p><img src="https://upload-images.jianshu.io/upload_images/14942208-147d403d5e50196b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/312/format/webp" alt="img"></p> <p>每个守卫方法接收三个参数：</p> <p>①<strong>to: Route</strong>: 即将要进入的目标<a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener noreferrer">路由对象<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（to 是一个对象，是将要进入的路由对象，可以用<strong>to.path</strong>调用路由对象中的属性）</p> <p>②<strong>from: Route</strong>: 当前导航正要离开的路由</p> <p>③<strong>next: Function</strong>: 这是一个必须需要调用的方法，执行效果依赖 next 方法的调用参数。</p> <p>next 参数：</p> <p><strong>next()</strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是<strong>confirmed</strong> (确认的)。</p> <p><strong>next(false)</strong>: **中断当前的导航。**如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按 钮)，那么 URL 地址会重置到 from 路由对应的地址。</p> <p><strong>next('/') 或者 next({ path: '/' })</strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在<a href="https://router.vuejs.org/zh/api/#to" target="_blank" rel="noopener noreferrer">router-link 的 to prop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>或<a href="https://router.vuejs.org/zh/api/#router-push" target="_blank" rel="noopener noreferrer">router.push<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的选项。</p> <p><strong>next(error)</strong>: (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给<a href="https://router.vuejs.org/zh/api/#router-onerror" target="_blank" rel="noopener noreferrer">router.onError()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>注册过的回调。</p> <p><strong>ps~ : 确保要调用 next 方法，否则钩子就不会被 resolved。</strong></p> <p><strong>(2). afterEach（全局后置钩子）</strong></p> <p><img src="https://upload-images.jianshu.io/upload_images/14942208-0e932e75e7230e5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/260/format/webp" alt="img"></p> <p>和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身</p> <h5 id="_2-路由独享的守卫-单个路由独享的"><a href="#_2-路由独享的守卫-单个路由独享的" class="header-anchor">#</a> <strong>2.路由独享的守卫(单个路由独享的)</strong></h5> <p><strong>写在路由配置中，只有访问到这个路径，才能触发钩子函数</strong></p> <p><img src="https://upload-images.jianshu.io/upload_images/14942208-7e61134f639d3991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/326/format/webp" alt="img"></p> <p>这些守卫与全局前置守卫的方法参数是一样的。</p> <h5 id="_3-组件级路由钩子"><a href="#_3-组件级路由钩子" class="header-anchor">#</a> <strong>3.组件级路由钩子</strong></h5> <p><strong>写在组件中,访问路径，即将渲染组件的时候触发的</strong></p> <blockquote><p>{</p> <p>data,</p> <p>methods</p> <p>beforeRouteEnter(){</p> <p>​ this 不指向实例 组件还没创建</p> <p>​ next((vm) =&gt;{</p> <p>​ vm 就是实例</p> <p>​ })</p> <p>}</p> <p>beforeRouteUpdate(){}</p> <p>beforeRouteLeave(){}</p> <p>}</p></blockquote> <p><img src="https://upload-images.jianshu.io/upload_images/14942208-ce6e88dc632eedf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633/format/webp" alt="img"></p> <p>beforeRouteEnter 守卫 <strong>不能</strong> 访问 <strong>this</strong>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p> <p><img src="https://upload-images.jianshu.io/upload_images/14942208-e15c09164823cf1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/282/format/webp" alt="img"></p> <p><strong>注意~ ：</strong> beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p> <p>这个**离开守卫 beforeRouteLeave()**通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p> <p><img src="https://upload-images.jianshu.io/upload_images/14942208-0b0d29ca76e7894e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/686/format/webp" alt="img"></p> <p>完整的导航解析流程：</p> <p>1.导航被触发。</p> <p>2.在失活的组件里调用离开守卫。</p> <p>3.调用全局的 beforeEach 守卫。</p> <p>4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p> <p>5.在路由配置里调用 beforeEnter。</p> <p>6.解析异步路由组件。</p> <p>7.在被激活的组件里调用 beforeRouteEnter。</p> <p>8.调用全局的 beforeResolve 守卫 (2.5+)。</p> <p>9.导航被确认。</p> <p>10.调用全局的 afterEach 钩子。</p> <p>11.触发 DOM 更新。</p> <p>12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p> <h3 id="react-生命周期钩子函数详解"><a href="#react-生命周期钩子函数详解" class="header-anchor">#</a> React 生命周期钩子函数详解</h3> <p>一、回顾 vue 中的生命周期</p> <p>beforeCreate created</p> <p>beforeMount mounted</p> <p>beforeUpdate updated</p> <p>beforeDestroy destroyed</p> <p>activated deactivated</p> <p>二、react 生命周期钩子函数</p> <p>初始化阶段</p> <p>constructor 初始化数据---初始化状态</p> <p>componentWillMount 以前建议进行 ajax 请求，最后一次修改状态的机会，但是现在基本上都 componentDidMount 中请求</p> <p>render 第一次装载（渲染）数据</p> <p>componentDidMount ajax 请求，更新状态，进入运行时阶段，更新视图，还可以实例化一些对象</p> <p>运行时阶段</p> <p>componentWillReceiveProps 子组件接收到父组件的数据</p> <p>shouldComponentUpdate 本组件是不是需要进行去更新视图，默认为 true，要不不写，写了必写返回值，false 表示不更新视图</p> <p>componentWillUpdate 组件即将被更新-----无实际意义</p> <p>render 重新渲染数据</p> <p>componentDidUpdate 实例化一些对象（特别是如果数据是动态请求的）</p> <p>销毁</p> <p>componentWillUnmount 清除一些计时器，定时器等</p> <p>错误异常处理</p> <p>componentDidCatch</p> <p>componentDidCatch --- 错误边界作为 React 组件，用以捕获在子组件树中任何地方的 JavaScript 异常，打印这些错误，并展示备用 UI 而非让组件树崩溃。错误边界会捕获渲染期间，在生命周期方法中以及在其整个树的构造函数中的异常。</p> <p>简单来说 就是使用异常的组件包裹 App 组件</p> <ErrorBoundary><App></App></ErrorBoundary> <p>ErrorBoundary 组件</p> <p>class ErrorBoundary extends <a href="http://react.component/" target="_blank" rel="noopener noreferrer">React.Component<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> {</p> <p>constructor(props) {</p> <p>super(props);</p> <p>this.state = { hasError: false };</p> <p>}</p> <p>componentDidCatch(error, info) {</p> <p>this.setState({ hasError: true });</p> <p>}</p> <p>render() {</p> <p>if (this.state.hasError) {</p> <p>return </p><h1>Something went wrong.</h1>;<p></p> <p>}</p> <p>return this.props.children;</p> <p>}</p> <p>}</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/yuguaa/books/edit/master/docs/misc/面试进阶.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">5/8/2021, 10:52:36 AM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/books/assets/js/app.b36598ad.js" defer></script><script src="/books/assets/js/76.fe474c6d.js" defer></script>
  </body>
</html>
