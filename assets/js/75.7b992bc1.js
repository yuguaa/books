(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{241:function(t,_,v){"use strict";v.r(_);var a=v(0),e=Object(a.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("div",{staticClass:"content"},[v("h3",{attrs:{id:"_1-为什么使用-promise，怎么使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么使用-promise，怎么使用"}},[t._v("#")]),t._v(" 1. 为什么使用 promise，怎么使用")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("解决异步请求成功时回调函数中继续书写代码造成的回调嵌套问题")])]),t._v(" "),v("li",[v("p",[t._v("在代码中 return 出来一个 Promise.resolve（）；")])]),t._v(" "),v("li",[v("p",[t._v("当多个异步任务需要先后执行时，使用 Promise 连续.then 控制。")])]),t._v(" "),v("li",[v("p",[t._v("多个异步任务并发执行没有先后依赖时，使用 Promise.all 合并。")])])]),t._v(" "),v("h3",{attrs:{id:"_2-js-函数中的-this-究竟指向谁？怎样改变函数中-this-的指向。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-js-函数中的-this-究竟指向谁？怎样改变函数中-this-的指向。"}},[t._v("#")]),t._v(" 2. Js 函数中的 this 究竟指向谁？怎样改变函数中 this 的指向。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("独立存在的函数，直接调用时，非严格模式下其中的 this 指向全局对象(浏览器中是 window,nodejs 中是 global)，严格模式下指向 undefined。")])]),t._v(" "),v("li",[v("p",[t._v("如果是对象的方法，则通过谁调用，就指向谁。")])]),t._v(" "),v("li",[v("p",[t._v("构造函数通过 new 调用时，this 是正在创建的对象。")])]),t._v(" "),v("li",[v("ul",[v("li",[t._v("函数中的 this 是可以通过方法改变的。")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("call ，call 是函数对象的方法，作用是指定 this，调用这个函数。")])]),t._v(" "),v("li",[v("p",[t._v("apply，和 call 基本一样，唯一的区别是，传参方式不同，apply 需要提供一个数组。")])]),t._v(" "),v("li",[v("p",[t._v("bind，bind 也是函数对象的方法，作用是生成一个新的函数，新的函数和原函数代码一样，但是里面的 this 是绑定过的。")])])])])]),t._v(" "),v("h3",{attrs:{id:"_3-如何保证一个类中的很多方法（函数）不管怎么调用，this-总是指向实例对象？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何保证一个类中的很多方法（函数）不管怎么调用，this-总是指向实例对象？"}},[t._v("#")]),t._v(" 3. 如何保证一个类中的很多方法（函数）不管怎么调用，this 总是指向实例对象？")]),t._v(" "),v("ul",[v("li",[t._v("在类中声明实例方法时直接声明为箭头函数,或者添加 bind(this)，")]),t._v(" "),v("li",[t._v("在构造函数中对实例方法进行 bind(this)。")])]),t._v(" "),v("h3",{attrs:{id:"_4-什么是原型和原型链？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么是原型和原型链？"}},[t._v("#")]),t._v(" 4. 什么是原型和原型链？")]),t._v(" "),v("p",[t._v("https://blog.csdn.net/xiaoermingn/article/details/80745117")]),t._v(" "),v("p",[t._v("Js 中的对象都有一个属性叫做"),v("strong",[t._v("proto")]),t._v("(也是一个对象)，表示对象的原型。当访问对象中的属性或方法时，首先在对象本身中寻找，如果找不到则会在原型中寻找，原型中也找不到时会在原型的原型中寻找，直到最顶层为止。")]),t._v(" "),v("p",[t._v("js 中的类(构造函数)都有一个 prototype 的属性，表示本类的原型类型，通过这个类实例化的对象(这个构造函数创建的对象)， "),v("strong",[t._v("proto")]),t._v("都指向本类的 prototype，从而实现了类方法的共享。一个类的 prototype 也是一个对象，它也有"),v("strong",[t._v("proto")]),t._v("，把它的"),v("strong",[t._v("proto")]),t._v("指向另一个类的 prototype 时，那么这个类的对象就能访问另一个类中的方法，从而实现了方法的继承。")]),t._v(" "),v("p",[t._v("A 类的 prototype."),v("strong",[t._v("proto")]),t._v("指向另一个类 B，B 的 prototype."),v("strong",[t._v("proto")]),t._v("又可以指向 C，这种结构叫做原型链。")]),t._v(" "),v("h3",{attrs:{id:"_5-闭包是什么？有什么作用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-闭包是什么？有什么作用？"}},[t._v("#")]),t._v(" 5. 闭包是什么？有什么作用？")]),t._v(" "),v("p",[t._v("https://www.haorooms.com/post/js_bb")]),t._v(" "),v("p",[t._v("当一个函数 A 的作用域被内部的 B 函数引用时，A 函数的作用域就会被 B 函数闭包，如果函数 A 返回了函数 B，当 A 函数执行完毕时，A 函数的作用域也不会释放。")]),t._v(" "),v("p",[t._v("优点：")]),t._v(" "),v("p",[t._v("闭包可以实现对象的私有属性和私有方法。")]),t._v(" "),v("p",[t._v("闭包可以封装变量，从简减少对全局作用域的污染。")]),t._v(" "),v("p",[t._v("缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致"),v("strong",[t._v("内存泄露")]),t._v("。"),v("strong",[t._v("解决方法是，在退出函数之前，将不使用的局部变量全部删除。")])]),t._v(" "),v("h3",{attrs:{id:"_6-es6-新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-es6-新特性"}},[t._v("#")]),t._v(" 6. ES6 新特性")]),t._v(" "),v("p",[t._v("https://www.jianshu.com/p/ac1787f6c50f")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("1.不一样的变量声明：const 和 let")])]),t._v(" "),v("li",[v("p",[t._v("2.模板字符串")])]),t._v(" "),v("li",[v("p",[t._v("3.箭头函数（Arrow Functions）")])]),t._v(" "),v("li",[v("p",[t._v("ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体；")]),t._v(" "),v("ul",[v("li",[t._v("不需要 function 关键字来创建函数")]),t._v(" "),v("li",[t._v("省略 return 关键字")]),t._v(" "),v("li",[t._v("继承当前上下文的 this 关键字")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"4"}},[v("li",[t._v("函数的参数默认值")])]),t._v(" "),v("p",[t._v("在 ES6 之前，我们往往这样定义参数的默认值：")])]),t._v(" "),v("li",[v("p",[t._v("5.Spread / Rest 操作符")]),t._v(" "),v("p",[t._v("Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。")])]),t._v(" "),v("li",[v("p",[t._v("6.二进制和八进制字面量")]),t._v(" "),v("p",[t._v("ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者 0O 即可将其转换为八进制值：")])]),t._v(" "),v("li",[v("p",[t._v("7.对象和数组解构")])]),t._v(" "),v("li",[v("p",[t._v("8.对象超类")])]),t._v(" "),v("li",[v("p",[t._v("9.for...of 和 for...in")]),t._v(" "),v("p",[t._v("for...of 用于遍历一个迭代器，for...in 用来遍历对象中的属性：")])]),t._v(" "),v("li",[v("p",[t._v("10.ES6 中的类")]),t._v(" "),v("p",[t._v("ES6 中支持 class 语法，不过，ES6 的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。")])])]),t._v(" "),v("h3",{attrs:{id:"_7-什么是跨域请求，怎样实现跨域请求。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-什么是跨域请求，怎样实现跨域请求。"}},[t._v("#")]),t._v(" 7.什么是跨域请求，怎样实现跨域请求。")]),t._v(" "),v("p",[t._v("协议不同算跨域，例如："),v("code",[t._v("http")]),t._v("和"),v("code",[t._v("https")]),t._v("。\n端口号不同算跨域，例如："),v("code",[t._v("80")]),t._v("和"),v("code",[t._v("8080")]),t._v("。\n域名不同算跨域，例如："),v("code",[t._v("baidu.com")]),t._v("和"),v("code",[t._v("jingdong.com")]),t._v("\n以上出现一种就算是跨域")]),t._v(" "),v("p",[t._v("一个页面发送到非本身来源的请求叫做跨域请求，浏览器只禁止 ajax 跨域请求。")]),t._v(" "),v("p",[t._v("三种跨域请求的方式：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("1，cors，服务器在响应头中添加 access control allow origin 字段，浏览器在收到请求之后就会认为本次请求时允许跨域的。")])]),t._v(" "),v("li",[v("p",[t._v("2，JSONP,浏览器使用创建 script 标签的形式发送请求，将一个函数名作为请求参数发给服务器，服务器将需要返回的数据封装在一段 js 代码中（把前端发来的函数名进行调用，把要发送的数据作为参数），然后把这段代码返回给前端，前端立刻执行这个函数。")]),t._v(" "),v("p",[t._v("JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。")])]),t._v(" "),v("li",[v("p",[t._v("3，代理服务器，将请求先发送给代理服务器，代理服务器装发给目标服务器。")])])]),t._v(" "),v("h3",{attrs:{id:"_8-cookie-和-localstorage-有什么区别？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-cookie-和-localstorage-有什么区别？"}},[t._v("#")]),t._v(" 8. cookie 和 localstorage 有什么区别？")]),t._v(" "),v("p",[t._v("都可以实现在用户的浏览器中存储一些数据。")]),t._v(" "),v("p",[t._v("不同：cookie 是由服务端主导的，主要用于存储用户身份验证信息。localstorage 是由前端 js 控制的，主要用于缓存业务逻辑数据。Cookie 会随着请求头和响应头往返于服务器和浏览器之间。")]),t._v(" "),v("p",[t._v("LocalStorage 能存储多少数据量？如果数量过大会出现什么问题？怎么办？")]),t._v(" "),v("p",[t._v("不同浏览器有区别，一般都是 5MB 左右。")]),t._v(" "),v("h3",{attrs:{id:"_9-vue-的组件配置对象中都有哪些常用字段？分别是什么作用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-的组件配置对象中都有哪些常用字段？分别是什么作用？"}},[t._v("#")]),t._v(" 9. vue 的组件配置对象中都有哪些常用字段？分别是什么作用？")]),t._v(" "),v("p",[t._v("Data,props,computed,components,methods,watch,filters,mounted 等生命周期函数")]),t._v(" "),v("h5",{attrs:{id:"什么时候使用-watch？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么时候使用-watch？"}},[t._v("#")]),t._v(" 什么时候使用 watch？")]),t._v(" "),v("p",[t._v("需要监听组件数据变化时")]),t._v(" "),v("h5",{attrs:{id:"watch-可以监视什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watch-可以监视什么？"}},[t._v("#")]),t._v(" watch 可以监视什么？")]),t._v(" "),v("p",[t._v("凡是 vue 组件改造的 set,get 属性，都可以监听。")]),t._v(" "),v("h5",{attrs:{id:"mixin-都能混入什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mixin-都能混入什么？"}},[t._v("#")]),t._v(" mixin 都能混入什么？")]),t._v(" "),v("p",[t._v("Data，methods，生命周期钩子函数，")]),t._v(" "),v("h5",{attrs:{id:"列举一下-vue-生命周期方法，什么时候需要在-destroyed-中写代码？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#列举一下-vue-生命周期方法，什么时候需要在-destroyed-中写代码？"}},[t._v("#")]),t._v(" 列举一下 Vue 生命周期方法，什么时候需要在 destroyed 中写代码？")]),t._v(" "),v("p",[t._v("Mounted,created,destroyed,updated, activated,")]),t._v(" "),v("h5",{attrs:{id:"为了提高性能，开启了-vue-route-的-keep-alive-功能，结果发现-beforeupdate-不会调用了，怎么解决？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为了提高性能，开启了-vue-route-的-keep-alive-功能，结果发现-beforeupdate-不会调用了，怎么解决？"}},[t._v("#")]),t._v(" 为了提高性能，开启了 vue-route 的 keep-alive 功能，结果发现 beforeUpdate 不会调用了，怎么解决？")]),t._v(" "),v("p",[t._v("activited")]),t._v(" "),v("h3",{attrs:{id:"_10-vue-中数据绑定是怎么实现的？双向绑定指令-v-model-的本质是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-中数据绑定是怎么实现的？双向绑定指令-v-model-的本质是什么？"}},[t._v("#")]),t._v(" 10. vue 中数据绑定是怎么实现的？双向绑定指令 v-model 的本质是什么？")]),t._v(" "),v("p",[t._v("Vue 组件 data 中的数据在组件创建时，都会被改造为 set,get 类型的属性，当数据发生变化时 set 方法就会调用，set 方法中添加了重新渲染的代码。")]),t._v(" "),v("p",[t._v("v-model 相当于 v-bind:value 加 v-on:input")]),t._v(" "),v("h3",{attrs:{id:"_11-vue-中怎么实现非父子组件之间的传值？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-中怎么实现非父子组件之间的传值？"}},[t._v("#")]),t._v(" 11. vue 中怎么实现非父子组件之间的传值？")]),t._v(" "),v("p",[t._v("在项目规模不是特别大时，可以创建一个空组件作为总线，项目中其他组件都可以通过总线进行传值。")]),t._v(" "),v("p",[t._v("大大型项目中，可以使用 vuex 进行数据管理，将数据统一放在 store 中进行管理。")]),t._v(" "),v("h5",{attrs:{id:"怎么找到父组件的父组件的父组件？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎么找到父组件的父组件的父组件？"}},[t._v("#")]),t._v(" 怎么找到父组件的父组件的父组件？")]),t._v(" "),v("p",[t._v("$parent. $parent. $parent.")]),t._v(" "),v("p",[t._v("怎么找出所有的子孙组件？")]),t._v(" "),v("p",[t._v("$children")]),t._v(" "),v("h5",{attrs:{id:"vuex-的核心概念有哪些？它们的作用是什么？组件如何使用-store-中的数据如何改变-store-中的数据？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex-的核心概念有哪些？它们的作用是什么？组件如何使用-store-中的数据如何改变-store-中的数据？"}},[t._v("#")]),t._v(" Vuex 的核心概念有哪些？它们的作用是什么？组件如何使用 store 中的数据如何改变 store 中的数据？")]),t._v(" "),v("p",[t._v("State，仓库中的状态（数据）。Getters，状态的衍生状态。Mutation，状态的修改方法。Actions，状态的异步修改方法。")]),t._v(" "),v("p",[t._v("使用 mapState 函数将 store 中的数据 map 到组件 compouted 中。")]),t._v(" "),v("p",[t._v("使用 mapAction 和 mapActions 函数将 store 中的修改方法 map 到组件的 methods 中。")]),t._v(" "),v("h3",{attrs:{id:"_12-websocket-是什么？适用于哪些网站？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-websocket-是什么？适用于哪些网站？"}},[t._v("#")]),t._v(" 12. webSocket 是什么？适用于哪些网站？")]),t._v(" "),v("p",[t._v("webSocket 是一种双工通信技术，可以实现服务器主动向客户端发送数据。")]),t._v(" "),v("h3",{attrs:{id:"_13-什么是-webworker？在哪些场景下需要使用-webworker？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-什么是-webworker？在哪些场景下需要使用-webworker？"}},[t._v("#")]),t._v(" 13. 什么是 WebWorker？在哪些场景下需要使用 WebWorker？")]),t._v(" "),v("p",[t._v("WebWorker 是 h5 中新增的 WebAPI，用于启动一个独立的线程，主线程和分线程只能通过相互发送消息进行通信。当前端页面中有耗时很长的代码需要执行时，可以放在 worker 中执行，否则会卡塞主线程，影响用户体验。")]),t._v(" "),v("h3",{attrs:{id:"_14-在浏览器地址栏输入一个网址，从敲下回车键，到页面完全加载完毕，中间都发生了什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-在浏览器地址栏输入一个网址，从敲下回车键，到页面完全加载完毕，中间都发生了什么？"}},[t._v("#")]),t._v(" 14.在浏览器地址栏输入一个网址，从敲下回车键，到页面完全加载完毕，中间都发生了什么？")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("1，如果地址栏中输入的是一个域名，浏览器会先使用自己的 DNS 缓存进行域名解析，转为 IP 地址，如果缓存中不存在，则会请求使用上层 DNS（操作系统的 DNS），操作系统会先查询本地 HOST 文件，如果 HOST 文件中不存在则会使用网络设置的 DNS 进行域名解析。最终得到域名对应的 IP 地址。")])]),t._v(" "),v("li",[v("p",[t._v("2，获得 IP 地址后，浏览器按照 IP 地址进行连接(tcp 连接)，连接成功之后按照 http 协议的格式（请求行，请求头，请求体）发送 http 请求，服务器会返回响应报文（响应行，响应头，响应体），浏览器收到响应报文后，会根据响应头中的 Content-Type 字段来决定如何进行下一步处理，对于普通的网页 Content-Type 值是 text/html，浏览器就会在页面中打开本次请求响应体中的数据。")])]),t._v(" "),v("li",[v("p",[t._v("3，在打开页面时，浏览器首先对 html 文本进行解析，创建 DOM 树，然后将每个节点渲染到页面上，其中如果出现了附带资源的标签（例如 img,script 等），浏览器会再次按照这些资源的 src 发送请求，当请求完成之后将请求内容插入到页面中，其中 script 标签资源是同步加载的，其他资源是异步加载的。")]),t._v(" "),v("h5",{attrs:{id:"打开一个有很多图片的页面时，浏览器与服务器会建立多少个连接？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#打开一个有很多图片的页面时，浏览器与服务器会建立多少个连接？"}},[t._v("#")]),t._v(" 打开一个有很多图片的页面时，浏览器与服务器会建立多少个连接？")]),t._v(" "),v("p",[t._v("一般情况下 1 个连接。如果图片来自不同的域名则会是多个连接。")])])]),t._v(" "),v("h3",{attrs:{id:"_15-如何优化网页打开的速度？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-如何优化网页打开的速度？"}},[t._v("#")]),t._v(" 15. 如何优化网页打开的速度？")]),t._v(" "),v("h5",{attrs:{id:"前端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端"}},[t._v("#")]),t._v(" 前端")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("1，尽量减少页面资源的请求次数（可以通过 base64 图片、合并图片、合并 js，css 文件实现）。")])]),t._v(" "),v("li",[v("p",[t._v("2，对页面代码进行压缩（主要是 js 代码压缩）")])]),t._v(" "),v("li",[v("p",[t._v("3，合理地使用懒加载。")])]),t._v(" "),v("li",[v("p",[t._v("4，对于不需要支持多国语言的中文网页，可以使用放弃使用 UTF-8，使用 GBK 编码。")]),t._v(" "),v("h5",{attrs:{id:"后端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后端"}},[t._v("#")]),t._v(" 后端")]),t._v(" "),v("p",[t._v("(以上是从前端角度进行优化，下面几条是从服务端角度优化)")])]),t._v(" "),v("li",[v("p",[t._v("5，网页中的静态资源使用 CDN 服务。")])]),t._v(" "),v("li",[v("p",[t._v("6，使用缓存，服务端使用 redis 进行接口缓存，同时在响应头中通过 lastmodified,Etag 等字段控制浏览器缓存。")])]),t._v(" "),v("li",[v("p",[t._v("7，使用 gzip 进行数据压缩。")])]),t._v(" "),v("li",[v("p",[t._v("8，使用多域名，部分浏览器对于同一个域名的并发请求量设置有上限，所以可以把页面资源分布在不同域名中，例如静态资源独自使用一个域名。")])])]),t._v(" "),v("h3",{attrs:{id:"_16-什么是-html-语义化？html-语义化的好处是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-什么是-html-语义化？html-语义化的好处是什么？"}},[t._v("#")]),t._v(" 16. 什么是 HTML 语义化？HTML 语义化的好处是什么？")]),t._v(" "),v("p",[t._v("​ html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;")]),t._v(" "),v("p",[t._v("​ 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;")]),t._v(" "),v("p",[t._v("​ 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;")]),t._v(" "),v("p",[t._v("​ 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。")]),t._v(" "),v("h3",{attrs:{id:"_17，http-协议的状态码都有哪些？分别是什么意思？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17，http-协议的状态码都有哪些？分别是什么意思？"}},[t._v("#")]),t._v(" 17，HTTP 协议的状态码都有哪些？分别是什么意思？")]),t._v(" "),v("h6",{attrs:{id:"_2-开头成功-3-开头进一步处理，使用缓存前端处理，重定向后端处理，4-开头前端错误-5-开头服务器错误"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-开头成功-3-开头进一步处理，使用缓存前端处理，重定向后端处理，4-开头前端错误-5-开头服务器错误"}},[t._v("#")]),t._v(" 2 开头成功 3 开头进一步处理，使用缓存前端处理，重定向后端处理，4 开头前端错误 5 开头服务器错误")]),t._v(" "),v("p",[t._v("​ 200，请求成功。")]),t._v(" "),v("p",[t._v("​ 301，重定向。")]),t._v(" "),v("p",[t._v("​ 304，使用缓存。")]),t._v(" "),v("p",[t._v("​ 403，禁止访问。")]),t._v(" "),v("p",[t._v("​ 404，资源不存在")]),t._v(" "),v("p",[t._v("​ 500，服务端错误。")]),t._v(" "),v("p",[t._v("​ 针对上述状态码 jQuery ajax 在什么时候触发 fail/error？")]),t._v(" "),v("p",[t._v("​ 只要请求有响应都会 success，只有请求失败才会 fail")]),t._v(" "),v("p",[t._v("​ Axios 什么情况下 catch？")]),t._v(" "),v("p",[t._v("​ 1，2，3 开头.then，4,5 开头.catch")]),t._v(" "),v("p",[t._v("​ Fetch 呢？")]),t._v(" "),v("p",[t._v("​ 1，2，3 开头.then，4,5 开头.catch")]),t._v(" "),v("h3",{attrs:{id:"_18-什么叫优雅降级和渐进增强？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-什么叫优雅降级和渐进增强？"}},[t._v("#")]),t._v(" 18.什么叫优雅降级和渐进增强？")]),t._v(" "),v("ul",[v("li",[t._v("都是解决网站对于老旧版本浏览器的兼容问题。\n"),v("ul",[v("li",[t._v("优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于 IE 独特的盒模型布局问题，针对不同版本的 IE 的 hack 实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效")]),t._v(" "),v("li",[t._v("渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。")])])])]),t._v(" "),v("h3",{attrs:{id:"_19-webpack-工具的功能是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-webpack-工具的功能是什么？"}},[t._v("#")]),t._v(" 19.webpack 工具的功能是什么？")]),t._v(" "),v("p",[t._v("​ Webpack 是为前端开发设计的自动化打包工具，能够对项目中的 js、css、图片等资源进行打包（其中 js 可以直接打包，其他类型资源需要各自对应的 loader 支持），相比于传统的 grunt、gulp 等构建工具，webpack 在打包 js 代码时，能够识别多种模块化语法，进行模块化打包。")]),t._v(" "),v("h5",{attrs:{id:"webpack-怎么打包图片到-js-中，原理是什么？打包到-js-中的图片怎么显示到页面上？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack-怎么打包图片到-js-中，原理是什么？打包到-js-中的图片怎么显示到页面上？"}},[t._v("#")]),t._v(" Webpack 怎么打包图片到 js 中，原理是什么？打包到 js 中的图片怎么显示到页面上？")]),t._v(" "),v("p",[t._v("​ 对于小图片，打包之后会形成 base64 图片，而大图片会打包成一个 url 地址。")]),t._v(" "),v("h5",{attrs:{id:"vue-项目中放在哪些位置的图片会被打包？如何避免大图被打包？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-项目中放在哪些位置的图片会被打包？如何避免大图被打包？"}},[t._v("#")]),t._v(" Vue 项目中放在哪些位置的图片会被打包？如何避免大图被打包？")]),t._v(" "),v("p",[t._v("放在 assets 中的静态资源会被打包，将大图片放在 public 文件夹中。")]),t._v(" "),v("h5",{attrs:{id:"webpack-怎么打包-css？原理是什么？打包到-js-中的-css-怎么加载到页面上？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack-怎么打包-css？原理是什么？打包到-js-中的-css-怎么加载到页面上？"}},[t._v("#")]),t._v(" Webpack 怎么打包 css？原理是什么？打包到 js 中的 css 怎么加载到页面上？")]),t._v(" "),v("p",[t._v("使用 css-loader 和 style-loader，打包原理是通过 js 代码在页面中创建 style 标签，然后将 css 代码插入。")]),t._v(" "),v("h5",{attrs:{id:"webpack-能否打包字体文件？能否打包字体图标？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack-能否打包字体文件？能否打包字体图标？"}},[t._v("#")]),t._v(" Webpack 能否打包字体文件？能否打包字体图标？")]),t._v(" "),v("p",[t._v("​ 能，需要 file-loader。")]),t._v(" "),v("h5",{attrs:{id:"webpack-如何生成多个-html-页面？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack-如何生成多个-html-页面？"}},[t._v("#")]),t._v(" Webpack 如何生成多个 HTML 页面？")]),t._v(" "),v("p",[t._v("​ 将 webpack 配置文件中的打包入口配置为多个入口。")]),t._v(" "),v("h5",{attrs:{id:"webpack-怎么实现将某个模块（在项目的-node-modules-中）中的文件复制到编译输出文件夹中？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack-怎么实现将某个模块（在项目的-node-modules-中）中的文件复制到编译输出文件夹中？"}},[t._v("#")]),t._v(" Webpack 怎么实现将某个模块（在项目的 node_modules 中）中的文件复制到编译输出文件夹中？")]),t._v(" "),v("p",[t._v("​ 使用 CopyWebpackPlugin 插件，将要拷贝的文件添加到 webpack 的配置文件中。")]),t._v(" "),v("h5",{attrs:{id:"webpack-的核心概念有哪些，你能画一副图表示编译过程码？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的核心概念有哪些，你能画一副图表示编译过程码？"}},[t._v("#")]),t._v(" Webpack 的核心概念有哪些，你能画一副图表示编译过程码？")]),t._v(" "),v("p",[t._v("​ ![img](file:///C:\\Users\\yuguaa\\AppData\\Local\\Temp\\ksohtml\\wps61BC.tmp.jpg)")]),t._v(" "),v("h3",{attrs:{id:"_20-安全问题？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-安全问题？"}},[t._v("#")]),t._v(" 20.安全问题？")]),t._v(" "),v("p",[t._v("https://blog.csdn.net/l666q/article/details/103739239")]),t._v(" "),v("p",[t._v("https://www.cnblogs.com/superSmile/p/8039451.html")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Xss(cross-site scripting)攻击指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。")]),t._v(" "),v("ul",[v("li",[t._v("防范：首先代码里对用户输入的地方和变量都需要仔细检查长度和对<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以 encode，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的 XSS 攻击。避免直接在 cookie 中泄露用户隐私，例如 email、密码等等。其次，通过使 cookie 和系统 ip 绑定来降低 cookie 泄露后的危险。这样攻击者得到的 cookie 没有实际价值，不可能拿来重放。如果网站不需要再浏览器端对 cookie 进行操作，可以在 Set-Cookie 末尾加上 HttpOnly 来防止 javascript 代码直接获取 cookie 。")])])]),t._v(" "),v("li",[v("p",[t._v("什么是 CSRF 攻击？怎么防范？")]),t._v(" "),v("p",[t._v("Cross—Site Request Forgery，跨域请求伪造。")]),t._v(" "),v("p",[t._v("CSRF 攻击攻击原理及过程如下：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；")])]),t._v(" "),v("li",[v("p",[t._v("在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；")])]),t._v(" "),v("li",[v("p",[t._v("用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；")])]),t._v(" "),v("li",[v("p",[t._v("网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；")])]),t._v(" "),v("li",[v("p",[t._v("浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。")])]),t._v(" "),v("li",[v("p",[t._v("防范：在服务端敏感接口中添加 referer 判断。")])])])])]),t._v(" "),v("h3",{attrs:{id:"_21-http-和-https-的区别是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-http-和-https-的区别是什么？"}},[t._v("#")]),t._v(" 21. HTTP 和 HTTPS 的区别是什么？")]),t._v(" "),v("p",[t._v("HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL），这个时候，就成了我们常说的 HTTPS。")]),t._v(" "),v("p",[t._v("默认 HTTP 的端口号为 80，HTTPS 的端口号为 443。")]),t._v(" "),v("p",[t._v("为什么 HTTPS 安全")]),t._v(" "),v("p",[t._v("因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。https 之所以比 http 安全，是因为他利用 ssl/tls 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等。保障了传输过程的安全性")]),t._v(" "),v("h3",{attrs:{id:"_22-栈和队列的区别是什么-js-中怎样实现栈结构？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22-栈和队列的区别是什么-js-中怎样实现栈结构？"}},[t._v("#")]),t._v(" 22. 栈和队列的区别是什么?js 中怎样实现栈结构？")]),t._v(" "),v("p",[t._v("栈和队列都是线型数据结构，栈只有一个入口，同时也是出口，所以数据遵循先进后出，后进先出的规则。队列一侧是入口，另一侧是出口，所以数据先进先出，后进后出。")]),t._v(" "),v("p",[t._v("Js 中的数组可以实现栈和队列。Push 和 pop 方法是一对栈操作，push 和 shift 是一对队列操作。")]),t._v(" "),v("h3",{attrs:{id:"_23-cookie-和-session-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23-cookie-和-session-的区别"}},[t._v("#")]),t._v(" 23.cookie 和 session 的区别?")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。Session 基于 cookie。")])]),t._v(" "),v("li",[v("p",[t._v("2、cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗")])]),t._v(" "),v("li",[v("p",[t._v("3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能")])]),t._v(" "),v("li",[v("p",[t._v("4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。")])])]),t._v(" "),v("h3",{attrs:{id:"_24-如何为对象添加-set-get-属性？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_24-如何为对象添加-set-get-属性？"}},[t._v("#")]),t._v(" 24. 如何为对象添加 set/get 属性？")]),t._v(" "),v("p",[t._v("使用对象的自定义属性的方法，definepropoty，")]),t._v(" "),v("p",[t._v("可以自定义对象的属性，对象的属性可以设置成 setget 属性，可以通过这种方法控制对象属性的读写，类型")]),t._v(" "),v("h3",{attrs:{id:"_25-react-的组件有哪些声明方式？区别是什么？、"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_25-react-的组件有哪些声明方式？区别是什么？、"}},[t._v("#")]),t._v(" 25. react 的组件有哪些声明方式？区别是什么？、")]),t._v(" "),v("p",[t._v("总共有两种，一种是函数式组件声明，一种是类组件声明")]),t._v(" "),v("p",[t._v("函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[t._v("**区别**")])]),t._v(" "),v("th",[v("strong",[t._v("**函数组件**")])]),t._v(" "),v("th",[v("strong",[t._v("**类组件**")])])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("是否有 this")]),t._v(" "),v("td",[t._v("没有")]),t._v(" "),v("td",[t._v("有")])]),t._v(" "),v("tr",[v("td",[t._v("是否有生命周期")]),t._v(" "),v("td",[t._v("没有")]),t._v(" "),v("td",[t._v("有")])]),t._v(" "),v("tr",[v("td",[t._v("是否有状态 state")]),t._v(" "),v("td",[t._v("没有")]),t._v(" "),v("td",[t._v("有")])])])]),t._v(" "),v("h3",{attrs:{id:"_26-es6-的-async-函数怎么使用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_26-es6-的-async-函数怎么使用？"}},[t._v("#")]),t._v(" 26. ES6 的 async 函数怎么使用？")]),t._v(" "),v("p",[t._v("​ Async 函数没有返回值，或者只能返回 Promise 对象。在 async 函数的函数体中可以使用 await，await 后面只能调用返回 Promise 的函数，且通过 await 调用之后返回值不再是 promise，而是 promise.then 时所传递的数据（如果失败则会抛异常）。从而实现以同步代码的格式调用异步函数。")]),t._v(" "),v("p",[t._v("​ Promise 通过 catch()捕获 reject 状态，async/await 如何捕获 reject 状态？")]),t._v(" "),v("p",[t._v("​ Try…catch")]),t._v(" "),v("p",[t._v("​ 如果 await 调用中的 Promise 是 reject 状态，await 下面的代码是否会执行？为什么？")]),t._v(" "),v("p",[t._v("​ 不执行，因为抛异常了。")]),t._v(" "),v("p",[t._v("如果 await 调用中的 Promise 一直是 pending 状态，await 下面的代码是否会执行？为什么？")]),t._v(" "),v("p",[t._v("​ 不执行，只有 promise 成功之后才会继续执行。")]),t._v(" "),v("h3",{attrs:{id:"_27-什么是深拷贝和浅拷贝？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_27-什么是深拷贝和浅拷贝？"}},[t._v("#")]),t._v(" 27.什么是深拷贝和浅拷贝？")]),t._v(" "),v("p",[t._v("浅拷贝就是只复制数组（对象）本身，而不复制其内容（引用类型的数据内容），最终两个数组中指向同一套数据。深拷贝则是既赋值本身也赋值内容。")]),t._v(" "),v("p",[t._v("Js 中对于引用类型的数据，默认进行的都是浅拷贝。")]),t._v(" "),v("h3",{attrs:{id:"_28-js-如何实现对数组（对象）的深拷贝？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_28-js-如何实现对数组（对象）的深拷贝？"}},[t._v("#")]),t._v(" 28. JS 如何实现对数组（对象）的深拷贝？")]),t._v(" "),v("p",[t._v("对于不含方法的纯数据对象，可以转为 JSON 字符串再解析为对象，对于包含方法的对象，则需要使用递归遍历其属性逐个赋值。")]),t._v(" "),v("h3",{attrs:{id:"_29-什么是-js-严格模式？怎么进入严格模式？严格模式下有哪些限制？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_29-什么是-js-严格模式？怎么进入严格模式？严格模式下有哪些限制？"}},[t._v("#")]),t._v(" 29.什么是 JS 严格模式？怎么进入严格模式？严格模式下有哪些限制？")]),t._v(" "),v("p",[t._v("严格模式是 JS 的一种特殊执行模式，设立”严格模式”的目的，主要有以下几个：")]),t._v(" "),v("p",[t._v("1，消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;")]),t._v(" "),v("p",[t._v("2， 消除代码运行的一些不安全之处，保证代码运行的安全；")]),t._v(" "),v("p",[t._v("3，提高编译器效率，增加运行速度；")]),t._v(" "),v("p",[t._v("4， 为未来新版本的 Javascript 做好铺垫。")]),t._v(" "),v("p",[t._v("在函数中或全局域的开头添加字符串”use strict”进入严格模式。")]),t._v(" "),v("p",[t._v("严格模式主要有以下限制：")]),t._v(" "),v("p",[t._v("变量必须声明后再使用")]),t._v(" "),v("p",[t._v("函数的参数不能有同名属性，否则报错")]),t._v(" "),v("p",[t._v("不能使用 with 语句")]),t._v(" "),v("p",[t._v("不能对只读属性赋值，否则报错")]),t._v(" "),v("p",[t._v("不能使用前缀 0 表示八进制数，否则报错")]),t._v(" "),v("p",[t._v("不能删除不可删除的属性，否则报错")]),t._v(" "),v("p",[t._v("不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]")]),t._v(" "),v("p",[t._v("eval 不会在它的外层作用域引入变量")]),t._v(" "),v("p",[t._v("eval 和 arguments 不能被重新赋值")]),t._v(" "),v("p",[t._v("arguments 不会自动反映函数参数的变化")]),t._v(" "),v("p",[t._v("不能使用 arguments.callee")]),t._v(" "),v("p",[t._v("不能使用 arguments.caller")]),t._v(" "),v("p",[t._v("禁止 this 指向全局对象")]),t._v(" "),v("p",[t._v("不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈")]),t._v(" "),v("p",[t._v("增加了保留字（比如 protected、static 和 interface）")]),t._v(" "),v("h3",{attrs:{id:"_30-什么是函数防抖和函数节流？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_30-什么是函数防抖和函数节流？"}},[t._v("#")]),t._v(" 30.什么是函数防抖和函数节流？")]),t._v(" "),v("p",[t._v("函数防抖：对于频繁触发的事件，如果只希望其最后一次（或第一次）执行绑定函数的执行，则需要使用函数防抖。")]),t._v(" "),v("p",[t._v("函数节流：对于频繁触发的事件，希望其按照一定的频率进行绑定函数调用，则使用函数节流。")]),t._v(" "),v("p",[t._v("函数防抖和节流都可以通过 setTimeout 实现。")]),t._v(" "),v("h3",{attrs:{id:"_31-什么是-mvc-和-mvvm？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-什么是-mvc-和-mvvm？"}},[t._v("#")]),t._v(" 31.什么是 MVC 和 MVVM？"),v("img",{attrs:{src:"C:%5CUsers%5Cyuguaa%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704192227757.png",alt:"image-20200704192227757"}})]),t._v(" "),v("p",[t._v("​ MVC:model-view-controller")]),t._v(" "),v("p",[t._v("​ MVVM:model-view-view-model，")]),t._v(" "),v("p",[t._v("MVC 模式通过 controller 控制器协调 model 和 view 的交互，View 传送指令到 Controller，Controller 完成业务逻辑后，要求 Model 改变状态，Model 将新的数据发送到 View，用户得到反馈，所有通信都是单向的。")]),t._v(" "),v("p",[t._v("MVVM 模式使用数据双向绑定，model 和 view 直接进行交互。")]),t._v(" "),v("h3",{attrs:{id:"_32-js-的模块化技术都有哪些？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_32-js-的模块化技术都有哪些？"}},[t._v("#")]),t._v(" 32.js 的模块化技术都有哪些？")]),t._v(" "),v("p",[t._v("CommonJS，同步模块化标准，NodeJS 采用的就是这套标准。")]),t._v(" "),v("p",[t._v("AMD，异步模块化，requireJS 使用的标准。")]),t._v(" "),v("p",[t._v("ES6 模块化，ES 官方的标准，本质上也是一种同步模块化。")]),t._v(" "),v("h3",{attrs:{id:"_33-react-框架中高阶的作用是什么？哪些情况下使用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_33-react-框架中高阶的作用是什么？哪些情况下使用？"}},[t._v("#")]),t._v(" 33.React 框架中高阶的作用是什么？哪些情况下使用？")]),t._v(" "),v("p",[t._v("高阶组件的本质是一个函数，它接受一个函数组件，然后内部创建一个新组件，将函数组件包裹在新组件中，在新组件中扩展新的内容，最终返回新的组件。使用这种组件组合技术，可以将高阶组件和任何组件结合，从而实现高阶组件逻辑的复用。")]),t._v(" "),v("p",[t._v("当一个组件业务逻辑很复杂时，也可以将组件模板部分写成 function 组件，然后逻辑部分写为高阶组件和 function 组件结合，从而实现组件模板和逻辑的分离。")]),t._v(" "),v("p",[t._v("React 项目中常见 Container/Component 模式，Component 负责接收属性数据、渲染界面和调用函数属性（实现视图逻辑），Container 负责实现函数属性，Ajax 调用等（业务逻辑）；请分析这种模式的优缺点。")]),t._v(" "),v("p",[t._v("能够将组件的视图部分和逻辑部分进行分离，利于各自的开发和后续维护，尤其是大型组件，可以实现代码分散。缺点是两个组件之间增加了传值的代价（例如 ref），把 MVVM 的结构搞出了 MVC 的味道。")]),t._v(" "),v("h5",{attrs:{id:"如何调试-redux，查看当前状态、action-数据流？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何调试-redux，查看当前状态、action-数据流？"}},[t._v("#")]),t._v(" 如何调试 Redux，查看当前状态、action 数据流？")]),t._v(" "),v("p",[t._v("浏览器安装 react 调试插件。")]),t._v(" "),v("h3",{attrs:{id:"_34-vue-框架中标签的-ref-属性有什么作用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_34-vue-框架中标签的-ref-属性有什么作用？"}},[t._v("#")]),t._v(" 34.vue 框架中标签的 ref 属性有什么作用？")]),t._v(" "),v("p",[t._v("在组件代码中获取原生 HTML 标签对象，或者获取组件对象。")]),t._v(" "),v("h3",{attrs:{id:"_35-babel-的作用是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_35-babel-的作用是什么？"}},[t._v("#")]),t._v(" 35.babel 的作用是什么？")]),t._v(" "),v("p",[t._v("​ 将 ES6 代码转为 ES5 代码。")]),t._v(" "),v("h5",{attrs:{id:"babel-会进行哪几类转换？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#babel-会进行哪几类转换？"}},[t._v("#")]),t._v(" babel 会进行哪几类转换？")]),t._v(" "),v("p",[t._v("​ Es6/7 转 es5，jsx 转 js，ts 转 js,")]),t._v(" "),v("h5",{attrs:{id:"babel-插件和预设是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#babel-插件和预设是什么？"}},[t._v("#")]),t._v(" babel 插件和预设是什么？")]),t._v(" "),v("p",[t._v("​ Babel 插件可以在 babel 进行代码转换时使用一些额外的功能，插件预设就是一组插件列表。")]),t._v(" "),v("h5",{attrs:{id:"如何让-babel-针对特定浏览器转换出最精简和高效的代码？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何让-babel-针对特定浏览器转换出最精简和高效的代码？"}},[t._v("#")]),t._v(" 如何让 babel 针对特定浏览器转换出最精简和高效的代码？")]),t._v(" "),v("p",[t._v("​ 使用 preset-env 预设。")]),t._v(" "),v("h3",{attrs:{id:"_36-怎么解决页面加载时的闪烁问题？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_36-怎么解决页面加载时的闪烁问题？"}},[t._v("#")]),t._v(" 36.怎么解决页面加载时的闪烁问题？")]),t._v(" "),v("p",[t._v("​ 对页面整体内容进行隐藏，显示加载进度条，然后在页面的加载完毕事件中取消进度条，显示页面内容。")]),t._v(" "),v("p",[t._v("​ 在 vue 中可以通过 v-cloak 指令进行。")])])}],!1,null,null,null);_.default=e.exports}}]);